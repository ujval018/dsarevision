<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Notes: Strings (A-Z Revision)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        h1, h2, h3 {
            font-weight: 700;
            color: #0f172a;
        }
        h1 {
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }
        h2 {
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
            margin-top: 2.5rem;
        }
        h3 {
            margin-top: 1.5rem;
            font-weight: 600;
        }
        pre[class*="language-"] {
            font-family: 'Fira Code', monospace;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
        }
        code[class*="language-"] {
            font-family: 'Fira Code', monospace;
        }
        .flashcard {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
        }
        .flashcard-q {
            font-weight: 600;
            color: #475569;
        }
        .flashcard-a {
            margin-top: 0.5rem;
            color: #334155;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        hr {
            border-color: #cbd5e1;
            margin-top: 2.5rem;
            margin-bottom: 2.5rem;
        }
        .approach-note {
            margin-top: 0.5rem;
            margin-bottom: 0.75rem;
            font-style: italic;
            color: #475569;
            border-left: 3px solid #94a3b8;
            padding-left: 0.75rem;
        }
    </style>
</head>
<body class="antialiased">

    <nav class="bg-slate-800 text-white shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-6xl">
            <div class="flex items-center justify-between h-16">
                <div class="flex-shrink-0">
                    <a href="index.html" class="text-2xl font-bold text-white hover:text-slate-200 transition">DSA Revision Hub</a>
                </div>
                <div class="hidden md:block">
                    <div class="ml-10 flex items-baseline space-x-2">
                        <a href="array.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Arrays</a>
                        <a href="string.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Strings</a>
                        <a href="ll.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Linked List</a>
                        <a href="stack.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Stack</a>
                        <a href="queue_deque.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Queue/Deque</a>
                        <a href="tree.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Tree</a>
                        <a href="heap.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Heap</a>
                        <a href="hashing.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Hashing</a>
                        <a href="sorting.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Sorting</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <div class="container pt-24">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold">📜 Strings: The Complete A-Z Guide</h1>
        </header>

        <main>
            <!-- Section 1: C++ std::string -->
            <section>
                <h2 class="text-3xl">1. C++ `std::string` Fundamentals</h2>
                <h3>Concept & Common Functions</h3>
                <p class="approach-note">The C++ `std::string` is a powerful class that manages character sequences. Unlike C-style character arrays, it handles its own memory management, provides a rich set of member functions, and integrates seamlessly with the C++ Standard Library.</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

void string_examples() {
    std::string s1 = "hello";
    std::string s2 = "world";

    // Concatenation
    std::string s3 = s1 + " " + s2; // "hello world"

    // Length/Size
    std::cout &lt;&lt; "Length: " &lt;&lt; s3.length() &lt;&lt; std::endl; // 11

    // Substring
    std::cout &lt;&lt; "Substring: " &lt;&lt; s3.substr(6, 5) &lt;&lt; std::endl; // "world"

    // Find
    size_t pos = s3.find("world");
    if (pos != std::string::npos) {
        std::cout &lt;&lt; "'world' found at index: " &lt;&lt; pos &lt;&lt; std::endl; // 6
    }

    // Conversion
    std::string num_str = "123";
    int num = std::stoi(num_str); // String to integer
    std::string converted_str = std::to_string(num); // Integer to string
}
</code></pre>
            </section>

            <hr>

            <!-- Section 2: Core Algorithmic Patterns -->
            <section>
                <h2 class="text-3xl">2. Core Algorithmic Patterns</h2>
                
                <h3>Check for Anagrams</h3>
                <p class="approach-note">Two strings are anagrams if they contain the same characters with the same frequencies. This can be checked by sorting both strings and comparing them, or more efficiently, by using a frequency map (an array or hash map).</p>
<pre><code class="language-cpp">
// O(n) time, O(1) space (for fixed alphabet size)
bool areAnagram(string s1, string s2){
    if (s1.length() != s2.length()) return false;
    
    const int CHAR_COUNT = 256;
    int count[CHAR_COUNT] = {0};

    for(int i = 0; i < s1.length(); i++){
        count[s1[i]]++;
        count[s2[i]]--;
    }

    for(int i = 0; i < CHAR_COUNT; i++){
        if(count[i] != 0) return false;
    }
    return true;
}
</code></pre>

                <h3>Check for Palindrome</h3>
                <p class="approach-note">A string is a palindrome if it reads the same forwards and backward. This is efficiently checked using a two-pointer approach, where one pointer starts from the beginning and the other from the end, moving towards the center.</p>
<pre><code class="language-cpp">
bool isPalindrome(string s) {
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
</code></pre>

                <h3>Check if a String is a Subsequence</h3>
                <p class="approach-note">A string `s1` is a subsequence of `s2` if `s1` can be obtained from `s2` by deleting zero or more characters of `s2`. This is checked with a two-pointer approach, advancing the pointer for `s1` only when a character matches.</p>
<pre><code class="language-cpp">
bool isSubsequence(string s1, string s2) {
    int i = 0, j = 0;
    while (i < s1.length() && j < s2.length()) {
        if (s1[i] == s2[j]) {
            i++;
        }
        j++;
    }
    return (i == s1.length());
}
</code></pre>
            </section>

            <hr>

            <!-- Section 3: Advanced Pattern Matching -->
            <section>
                <h2 class="text-3xl">3. Advanced Pattern Matching</h2>

                <h3>Rabin-Karp Algorithm</h3>
                <p class="approach-note">A pattern searching algorithm that uses a rolling hash to find a pattern in a text. It calculates a hash value for the pattern and for each substring of the text of the same length. If hashes match, it performs a character-by-character comparison to rule out collisions.</p>
<pre><code class="language-cpp">
void rabinKarp(const string& txt, const string& pat) {
    int d = 256; // Number of characters in the input alphabet
    int q = 101; // A prime number
    int M = pat.length();
    int N = txt.length();
    int p = 0; // Hash value for pattern
    int t = 0; // Hash value for txt window
    int h = 1;

    for (int i = 0; i < M - 1; i++) h = (h * d) % q;

    // Calculate initial hash values
    for (int i = 0; i < M; i++) {
        p = (d * p + pat[i]) % q;
        t = (d * t + txt[i]) % q;
    }

    // Slide the pattern over text one by one
    for (int i = 0; i <= N - M; i++) {
        if (p == t) { // If hashes match, check characters
            if (txt.substr(i, M) == pat) {
                cout << "Pattern found at index " << i << endl;
            }
        }
        // Calculate hash value for next window
        if (i < N - M) {
            t = (d * (t - txt[i] * h) + txt[i + M]) % q;
            if (t < 0) t = (t + q); // Ensure t is non-negative
        }
    }
}
</code></pre>

                <h3>Knuth-Morris-Pratt (KMP) Algorithm</h3>
                <p class="approach-note">An O(n+m) pattern searching algorithm that avoids redundant comparisons by using a precomputed "Longest Proper Prefix which is also Suffix" (LPS) array. The LPS array tells us how many characters to skip on a mismatch.</p>
<pre><code class="language-cpp">
// Fills lps[] for given pattern pat[0..M-1]
void computeLPSArray(const string& pat, int M, int* lps) {
    int length = 0;
    lps[0] = 0;
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) length = lps[length - 1];
            else { lps[i] = 0; i++; }
        }
    }
}

void KMPSearch(const string& pat, const string& txt) {
    int M = pat.length();
    int N = txt.length();
    int lps[M];
    computeLPSArray(pat, M, lps);

    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while (i < N) {
        if (pat[j] == txt[i]) { i++; j++; }
        if (j == M) {
            cout << "Found pattern at index " << i - j << endl;
            j = lps[j - 1];
        } else if (i < N && pat[j] != txt[i]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
}
</code></pre>
            </section>

            <hr>

            <!-- Section 4: Classic Problems -->
            <section>
                <h2 class="text-3xl">4. Classic String Problems</h2>

                <h3>Longest Substring Without Repeating Characters</h3>
                <p class="approach-note">Use the sliding window technique. Maintain a window of characters and a map or array to store the last seen index of each character. If a repeating character is found, move the left boundary of the window to the right of its last occurrence.</p>
<pre><code class="language-cpp">
int lengthOfLongestSubstring(string s) {
    vector<int> dict(256, -1);
    int maxLen = 0, start = -1;
    for (int i = 0; i != s.length(); i++) {
        if (dict[s[i]] > start)
            start = dict[s[i]];
        dict[s[i]] = i;
        maxLen = max(maxLen, i - start);
    }
    return maxLen;
}
</code></pre>

                <h3>String to Integer (atoi)</h3>
                <p class="approach-note">A parsing problem that requires careful handling of edge cases: leading whitespace, optional sign (+/-), non-digit characters, and integer overflow (clamping to INT_MAX/INT_MIN).</p>
<pre><code class="language-cpp">
int myAtoi(string s) {
    int i = 0, sign = 1;
    long long result = 0;
    while (i < s.length() && s[i] == ' ') i++; // Skip whitespace

    if (i < s.length() && (s[i] == '+' || s[i] == '-')) {
        sign = (s[i++] == '-') ? -1 : 1;
    }

    while (i < s.length() && isdigit(s[i])) {
        result = result * 10 + (s[i++] - '0');
        if (result * sign > INT_MAX) return INT_MAX;
        if (result * sign < INT_MIN) return INT_MIN;
    }
    return result * sign;
}
</code></pre>
            </section>

            <hr>

            <!-- Master Flashcards -->
            <section>
                <h2 class="text-3xl">🃏 Master Flashcards for Strings</h2>
                <div class="flashcard">
                    <p class="flashcard-q">Q: What is the most efficient way to check if two strings are anagrams?</p>
                    <p class="flashcard-a">A: Using a frequency map (e.g., an array of size 256). Time: O(n), Space: O(1).</p>
                </div>
                <div class="flashcard">
                    <p class="flashcard-q">Q: What is the time complexity of the KMP algorithm for pattern searching?</p>
                    <p class="flashcard-a">A: O(N + M), where N is the length of the text and M is the length of the pattern. This is because it never re-evaluates a text character.</p>
                </div>
                <div class="flashcard">
                    <p class="flashcard-q">Q: How can you check if string `s2` is a rotation of string `s1` in one line?</p>
                    <p class="flashcard-a">A: If `s1` and `s2` have the same length, check if `s2` is a substring of `s1 + s1`. Code: `s1.length() == s2.length() && (s1 + s1).find(s2) != string::npos;`</p>
                </div>
            </section>
        </main>

        <footer class="text-center mt-16 border-t pt-8">
            <p class="text-slate-500">✅ Revision pack complete: C++ `std::string`, core patterns, and advanced algorithms.</p>
        </footer>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>