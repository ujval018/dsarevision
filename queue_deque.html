<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Notes: Queues & Deques (A-Z Revision)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        h1, h2, h3 {
            font-weight: 700;
            color: #0f172a;
        }
        h1 {
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }
        h2 {
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
            margin-top: 2.5rem;
        }
        h3 {
            margin-top: 1.5rem;
            font-weight: 600;
        }
        pre[class*="language-"] {
            font-family: 'Fira Code', monospace;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
        }
        code[class*="language-"] {
            font-family: 'Fira Code', monospace;
        }
        .flashcard {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
        }
        .flashcard-q {
            font-weight: 600;
            color: #475569;
        }
        .flashcard-a {
            margin-top: 0.5rem;
            color: #334155;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        hr {
            border-color: #cbd5e1;
            margin-top: 2.5rem;
            margin-bottom: 2.5rem;
        }
        .approach-note {
            margin-top: 0.5rem;
            margin-bottom: 0.75rem;
            font-style: italic;
            color: #475569;
            border-left: 3px solid #94a3b8;
            padding-left: 0.75rem;
        }
    </style>
</head>
<body class="antialiased">

    <nav class="bg-slate-800 text-white shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-6xl">
            <div class="flex items-center justify-between h-16">
                <div class="flex-shrink-0">
                    <a href="index.html" class="text-2xl font-bold text-white hover:text-slate-200 transition">DSA Revision Hub</a>
                </div>
                <div class="hidden md:block">
                    <div class="ml-10 flex items-baseline space-x-2">
                        <a href="array.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Arrays</a>
                        <a href="string.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Strings</a>
                        <a href="ll.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Linked List</a>
                        <a href="stack.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Stack</a>
                        <a href="queue_deque.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Queue/Deque</a>
                        <a href="tree.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Tree</a>
                        <a href="heap.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Heap</a>
                        <a href="hashing.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Hashing</a>
                        <a href="sorting.html" class="text-slate-300 hover:bg-slate-700 hover:text-white px-3 py-2 rounded-md text-sm font-medium">Sorting</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <div class="container pt-24">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold">↔️ Queues & Deques: The Complete Guide</h1>
        </header>

        <main>
            <!-- Section 1: Queue Fundamentals -->
            <section>
                <h2 class="text-3xl">1. Queue Fundamentals</h2>
                <h3>Concept & Principle</h3>
                <p class="approach-note">A Queue is a linear data structure that follows the <strong>FIFO (First-In, First-Out)</strong> principle. It's like a line of people waiting for a service: the first person to join the line is the first person to be served. Queues are fundamental for algorithms like Breadth-First Search (BFS).</p>
                
                <h3>Array-based Queue</h3>
                <p class="approach-note">A simple implementation using a fixed-size array. It requires two pointers, `front` and `rear` (or `size` and `capacity`), to manage the elements. Prone to overflow if the array is full.</p>
<pre><code class="language-cpp">
class Queue {
    int size, cap, front;
    int *arr;
public:
    Queue(int c) { cap = c; size = 0; front = 0; arr = new int[cap]; }
    bool isFull() { return (size == cap); }
    bool isEmpty() { return (size == 0); }
    int getFront() { return isEmpty() ? -1 : arr[front]; }
    int getRear() { return isEmpty() ? -1 : arr[(front + size - 1) % cap]; }
    void enqueue(int x) {
        if (isFull()) return;
        int rear = (front + size) % cap;
        arr[rear] = x;
        size++;
    }
    void dequeue() {
        if (isEmpty()) return;
        front = (front + 1) % cap;
        size--;
    }
};
</code></pre>

                <h3>Linked List-based Queue</h3>
                <p class="approach-note">A dynamic implementation using linked list nodes. It avoids the overflow issue of arrays and can grow as needed. Requires `front` and `rear` pointers for O(1) enqueue and dequeue operations.</p>
<pre><code class="language-cpp">
struct QNode {
    int data;
    QNode *next;
    QNode(int d) : data(d), next(NULL) {}
};

class LLQueue {
    QNode *front, *rear;
public:
    LLQueue() { front = rear = NULL; }
    void enqueue(int x) {
        QNode* temp = new QNode(x);
        if (rear == NULL) { // If queue is empty
            front = rear = temp;
            return;
        }
        rear->next = temp;
        rear = temp;
    }
    void dequeue() {
        if (front == NULL) return; // If queue is empty
        QNode* temp = front;
        front = front->next;
        if (front == NULL) rear = NULL; // If queue becomes empty
        delete temp;
    }
};
</code></pre>
            </section>

            <hr>

            <!-- Section 2: Deque (Double-Ended Queue) -->
            <section>
                <h2 class="text-3xl">2. Deque (Double-Ended Queue)</h2>
                <h3>Concept</h3>
                <p class="approach-note">A Deque (pronounced "deck") is a more generalized version of a queue. It allows insertion and deletion from both the <strong>front and the rear</strong>. This flexibility makes it powerful for problems like the sliding window maximum.</p>

                <h3>Circular Array-based Deque</h3>
                <p class="approach-note">An efficient way to implement a deque. It uses a circular array to handle wrapping around the ends. The `front` pointer can move backward, and the `rear` pointer can move forward, both modulo the capacity.</p>
<pre><code class="language-cpp">
class Deque {
    int *arr;
    int front, size, cap;
public:
    Deque(int c) { cap = c; arr = new int[cap]; front = 0; size = 0; }
    bool isFull() { return size == cap; }
    bool isEmpty() { return size == 0; }
    void insertFront(int x) {
        if (isFull()) return;
        front = (front - 1 + cap) % cap;
        arr[front] = x;
        size++;
    }
    void insertRear(int x) {
        if (isFull()) return;
        int rear = (front + size) % cap;
        arr[rear] = x;
        size++;
    }
    void deleteFront() {
        if (isEmpty()) return;
        front = (front + 1) % cap;
        size--;
    }
    void deleteRear() {
        if (isEmpty()) return;
        size--;
    }
    int getFront() { return isEmpty() ? -1 : arr[front]; }
    int getRear() { return isEmpty() ? -1 : arr[(front + size - 1) % cap]; }
};
</code></pre>
            </section>

            <hr>

            <!-- Section 3: Classic Problems & Applications -->
            <section>
                <h2 class="text-3xl">3. Classic Problems & Applications</h2>

                <h3>Generate Numbers with Given Digits</h3>
                <p class="approach-note">A classic queue application. Start by enqueuing the initial digits. Then, in a loop, dequeue a number, print it, and enqueue new numbers formed by appending the given digits to the dequeued number.</p>
<pre><code class="language-cpp">
// Example: Generate binary numbers from 1 to n
void generateBinary(int n) {
    queue<string> q;
    q.push("1");
    for (int i = 0; i < n; i++) {
        string curr = q.front();
        q.pop();
        cout << curr << " ";
        q.push(curr + "0");
        q.push(curr + "1");
    }
}
</code></pre>

                <h3>Sliding Window Maximum</h3>
                <p class="approach-note">A prime use case for a deque. The deque stores indices of elements in the current window, maintaining them in decreasing order of their values. This ensures the front of the deque is always the index of the maximum element in the window.</p>
<pre><code class="language-cpp">
void printMaxK(const vector<int>& arr, int k) {
    deque<int> dq;
    // Process first window of size k
    for (int i = 0; i < k; ++i) {
        while (!dq.empty() && arr[i] >= arr[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }
    // Process remaining elements
    for (int i = k; i < arr.size(); ++i) {
        cout << arr[dq.front()] << " ";
        // Remove elements out of the current window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        // Remove smaller elements from the rear
        while (!dq.empty() && arr[i] >= arr[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }
    cout << arr[dq.front()] << endl;
}
</code></pre>
            </section>

            <hr>

            <!-- Master Flashcards -->
            <section>
                <h2 class="text-3xl">🃏 Master Flashcards for Queues & Deques</h2>
                <div class="flashcard">
                    <p class="flashcard-q">Q: What is the core principle of a Queue?</p>
                    <p class="flashcard-a">A: FIFO (First-In, First-Out).</p>
                </div>
                <div class="flashcard">
                    <p class="flashcard-q">Q: What is the main advantage of a Deque over a Queue?</p>
                    <p class="flashcard-a">A: It allows efficient (O(1)) insertion and deletion at both the front and the rear.</p>
                </div>
                <div class="flashcard">
                    <p class="flashcard-q">Q: What is the ideal data structure for solving the "Sliding Window Maximum" problem efficiently?</p>
                    <p class="flashcard-a">A: A Deque, which can find the max in each window in O(n) total time.</p>
                </div>
                <div class="flashcard">
                    <p class="flashcard-q">Q: Which algorithm commonly uses a queue for traversal?</p>
                    <p class="flashcard-a">A: Breadth-First Search (BFS) for trees and graphs.</p>
                </div>
            </section>
        </main>

        <footer class="text-center mt-16 border-t pt-8">
            <p class="text-slate-500">✅ Revision pack complete: Implementations, C++ STL, and Classic Algorithms.</p>
        </footer>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>